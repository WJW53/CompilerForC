<!-- by:wjw -->
# 设计细节

**其实不该设计为一个个的路由导航的，就一个url/路由，其他的全整为按钮即可的。。我只是为了熟练下Vue全家桶，才强行分成路由组件的，整的更复杂了，就是为了练习Vue全家桶的..**

`一开始打算为文法产生式做个双向映射的,后来忘了,然后写代码就挺复杂的..最后想起来了,可是已经完成了主要算法了...尴尬`

重新上传文件并提交后，清空所有的关于编译的data值（我都放在了vuex中维护）

进入哪个菜单选项中，就将对应的前一步骤的输出作为新输入重新显示在左侧的框框中
(仍然是从compilation中对应的data取值)

中间的那个转换代码按钮是基础组件中的一部分，始终存在，点击则在对应功能下更新右侧内容，

每次更新都是维护vuex中的state

**那个转换代码按钮我还是得重新设计啊, 不然组件间数据、函数调用不起来, C..**

## 词法分析

按构词规则识别单词,输出单词本身及种别码等
源程序(过滤掉注释、空格、回车换行等)->token(每个元素内容是:  token字段, 种别码, 类型, row, column),所以token是个二维数组..
调用出错处理程序


## 布局、路由、组件设计

tnd，后来我发现，我还是得先布局规划好啊，很多最好抽离成新的组件，而且要合理划分，不然用vuex做状态控制的时候会很麻烦啊。

左边预览区抽离一下、右边结果区表格要抽离一下，可以根据路由元里的某个信息判断一下哪些结构该生成，哪些结构不该生成。完后传递数据给组件


## 语法分析

我采用的是LR分析方法

规范规约过程中，`只要保证分析栈中总是活前缀(不含句柄之后的任意符号)`，就说明分析采取的移进/规约动作是正确的

两种构造识别活前缀的DFA的方法(两种方法本质是一样的)：
1. 项目->NFA->DFA
2. Closure->GO->DFA

### 求First集合

### 求Follow集合

Follow(A)为非终结符A后跟符号的集合,Follow(A)是所有句型中出现在紧接A之后的终结符或’#’

（1）对于开始符号，首先将#放入Follow集中

（2）形如A->αBβ

（α可以是终结符或者非终结符或者直接为空，`β可以是终结符或者非终结符`，注意β不能为空，B后面要有东西，注意β不能为空，B后面要有东西，注意β不能为空，B后面要有东西）

（3）形如A->αB(α可以是终结符或者非终结符或者直接为空)或者A->αBβ是一个产生式且β=>(上面有个闭包符号,打不出来,意思就是有限次推导后)ε