<!-- by:wjw -->
# 设计细节

**其实不该设计为一个个的路由导航的，就一个url/路由，其他的全整为按钮即可的。。我只是为了熟练下Vue全家桶，才强行分成路由组件的，整的更复杂了，就是为了练习Vue全家桶的..**

`一开始打算为文法产生式做个双向映射的,后来忘了,然后写代码就挺复杂的..最后想起来了,可是已经完成了主要算法了...尴尬`

重新上传文件并提交后，清空所有的关于编译的data值（我都放在了vuex中维护）

进入哪个菜单选项中，就将对应的前一步骤的输出作为新输入重新显示在左侧的框框中
(仍然是从compilation中对应的data取值)

中间的那个转换代码按钮是基础组件中的一部分，始终存在，点击则在对应功能下更新右侧内容，

每次更新都是维护vuex中的state

**那个转换代码按钮我还是得重新设计啊, 不然组件间数据、函数调用不起来, C..**

**最好还是用集合的形式存储好文法的顺序有利一些**

**注意文法里的VARIABLE::=IDentifier一定要有!!而且要将函数调用的变量与普通变量区分标识!!否则LR1也失败**

##
文法要注意优先级然后一定要消除左递归、回溯、闭包(转换写的形式,有公式的)

## 词法分析

按构词规则识别单词,输出单词本身及种别码等
源程序(过滤掉注释、空格、回车换行等)->token(每个元素内容是:  token字段, 种别码, 类型, row, column),所以token是个二维数组..
调用出错处理程序


## 布局、路由、组件设计

tnd，后来我发现，我还是得先布局规划好啊，很多最好抽离成新的组件，而且要合理划分，不然用vuex做状态控制的时候会很麻烦啊。

左边预览区抽离一下、右边结果区表格要抽离一下，可以根据路由元里的某个信息判断一下哪些结构该生成，哪些结构不该生成。完后传递数据给组件


## 语法分析

**其实,应该把所有形如A->ε的产生式,单独再存到一个变量里保存的,可惜最初我没这么做**

我采用的是LR分析方法

**最初写了LRO,SLR1,然后在292个状态中依然有两个状态冲突,故改为了LR(1)分析法,之前的内容存在了DFA_SLR1.vue这个路由组件中了**

`但是后来我更改了文法,并配合Token得到的token,改变了他们的Type,所以有些type本身就对应了我写的产生式里的非终结符,然后SLR1可以用了!!如果后续有时间的话,我会再写一个LR1,然后文法就可以有些小瑕疵了(比如Expression1那里,还有Number的拆分等等)...**好尴尬,真打脸,后续发现,..还是得写LR1**`

规范规约过程中，`只要保证分析栈中总是活前缀(不含句柄之后的任意符号)`，就说明分析采取的移进/规约动作是正确的

两种构造识别活前缀的DFA的方法(两种方法本质是一样的)：
1. 项目->NFA->DFA
2. Closure->GO(I,X)->DFA

### 求First集合

### 求Follow集合

Follow(A)为非终结符A后跟符号的集合,Follow(A)是所有句型中出现在紧接A之后的终结符或’#’

（1）对于开始符号，首先将#放入Follow集中

（2）形如A->αBβ

（α可以是终结符或者非终结符或者直接为空，`β可以是终结符或者非终结符`，注意β不能为空，B后面要有东西，注意β不能为空，B后面要有东西，注意β不能为空，B后面要有东西）

（3）形如A->αB(α可以是终结符或者非终结符或者直接为空)或者A->αBβ是一个产生式且β=>(上面有个闭包符号,打不出来,意思就是有限次推导后)ε